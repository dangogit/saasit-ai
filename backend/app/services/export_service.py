import json
import yaml
from typing import Dict, Any
from datetime import datetime

from app.models.project import Project, ProjectExport, ExportFormat


class ExportService:
    """Service for exporting projects in various formats"""
    
    async def export_project(self, project: Project, options: ProjectExport) -> Dict[str, Any]:
        """Export project based on format"""
        
        if options.format == ExportFormat.JSON:
            return self._export_as_json(project, options)
        elif options.format == ExportFormat.YAML:
            return self._export_as_yaml(project, options)
        elif options.format == ExportFormat.CLAUDE_CODE:
            return self._export_as_claude_code(project, options)
        elif options.format == ExportFormat.DOCKER:
            return self._export_as_docker(project, options)
        else:
            raise ValueError(f"Unsupported export format: {options.format}")
    
    def _export_as_json(self, project: Project, options: ProjectExport) -> Dict[str, Any]:
        """Export project as JSON"""
        export_data = {
            "project": {
                "name": project.name,
                "description": project.description,
                "created_at": project.created_at.isoformat(),
                "version": project.version
            },
            "workflow": project.workflow.model_dump(),
            "metadata": {
                "exported_at": datetime.utcnow().isoformat(),
                "export_format": "json",
                "saasit_version": "1.0.0"
            }
        }
        
        if options.include_readme:
            export_data["readme"] = self._generate_readme(project)
        
        if options.include_env_template:
            export_data["env_template"] = self._generate_env_template(project)
        
        return {
            "filename": f"{project.name.replace(' ', '_').lower()}_export.json",
            "content": json.dumps(export_data, indent=2),
            "content_type": "application/json"
        }
    
    def _export_as_yaml(self, project: Project, options: ProjectExport) -> Dict[str, Any]:
        """Export project as YAML"""
        export_data = {
            "project": {
                "name": project.name,
                "description": project.description,
                "created_at": project.created_at.isoformat(),
                "version": project.version
            },
            "workflow": project.workflow.model_dump(),
            "metadata": {
                "exported_at": datetime.utcnow().isoformat(),
                "export_format": "yaml",
                "saasit_version": "1.0.0"
            }
        }
        
        return {
            "filename": f"{project.name.replace(' ', '_').lower()}_export.yaml",
            "content": yaml.dump(export_data, default_flow_style=False),
            "content_type": "application/x-yaml"
        }
    
    def _export_as_claude_code(self, project: Project, options: ProjectExport) -> Dict[str, Any]:
        """Export project as Claude Code configuration"""
        # Extract agents from workflow
        agents = []
        for node in project.workflow.nodes:
            agent_data = node.data
            agents.append({
                "id": agent_data.get("id", node.id),
                "name": agent_data.get("name", "Unknown Agent"),
                "role": agent_data.get("description", ""),
                "capabilities": agent_data.get("capabilities", []),
                "tools": agent_data.get("tools", [])
            })
        
        # Extract dependencies from edges
        dependencies = {}
        for edge in project.workflow.edges:
            if edge.source not in dependencies:
                dependencies[edge.source] = []
            dependencies[edge.source].append(edge.target)
        
        claude_config = {
            "project_name": project.name,
            "description": project.description,
            "agents": agents,
            "workflow": {
                "type": project.workflow.layout,
                "dependencies": dependencies,
                "coordination": "AI-driven task allocation with dependency management"
            },
            "configuration": {
                "runtime": "claude-code-sdk",
                "version": "latest",
                "environment": {
                    "ANTHROPIC_API_KEY": "${ANTHROPIC_API_KEY}"
                }
            }
        }
        
        content = f"""# Claude Code Configuration
# Generated by SaasIt.ai on {datetime.utcnow().isoformat()}

{json.dumps(claude_config, indent=2)}
"""
        
        if options.include_readme:
            content += f"\n\n{self._generate_readme(project)}"
        
        return {
            "filename": f"{project.name.replace(' ', '_').lower()}_claude_code.json",
            "content": content,
            "content_type": "application/json"
        }
    
    def _export_as_docker(self, project: Project, options: ProjectExport) -> Dict[str, Any]:
        """Export project as Docker Compose configuration"""
        services = {}
        
        # Create a service for each agent
        for node in project.workflow.nodes:
            agent_data = node.data
            service_name = agent_data.get("id", node.id).replace("-", "_")
            
            services[service_name] = {
                "image": f"saasit/{agent_data.get('id', 'agent')}:latest",
                "environment": {
                    "AGENT_ID": agent_data.get("id", node.id),
                    "AGENT_NAME": agent_data.get("name", "Unknown Agent"),
                    "ANTHROPIC_API_KEY": "${ANTHROPIC_API_KEY}"
                },
                "restart": "unless-stopped",
                "networks": ["saasit-network"]
            }
        
        docker_compose = {
            "version": "3.8",
            "services": services,
            "networks": {
                "saasit-network": {
                    "driver": "bridge"
                }
            }
        }
        
        content = f"""# Docker Compose Configuration
# Generated by SaasIt.ai on {datetime.utcnow().isoformat()}
# Project: {project.name}

{yaml.dump(docker_compose, default_flow_style=False)}
"""
        
        return {
            "filename": "docker-compose.yml",
            "content": content,
            "content_type": "application/x-yaml"
        }
    
    def _generate_readme(self, project: Project) -> str:
        """Generate README content for the project"""
        agent_list = "\n".join([
            f"- **{node.data.get('name', 'Unknown')}**: {node.data.get('description', 'No description')}"
            for node in project.workflow.nodes
        ])
        
        return f"""# {project.name}

{project.description or 'AI-powered workflow generated by SaasIt.ai'}

## Workflow Overview

This project uses a {project.workflow.layout} workflow layout with {len(project.workflow.nodes)} specialized AI agents.

### Agents

{agent_list}

## Getting Started

1. Install Claude Code SDK
2. Set up your environment variables (see .env.example)
3. Run the workflow using Claude Code

## Environment Variables

- `ANTHROPIC_API_KEY`: Your Anthropic API key for Claude

## Generated by SaasIt.ai

This workflow was created using [SaasIt.ai](https://saasit.ai), the visual AI agent orchestrator.
"""
    
    def _generate_env_template(self, project: Project) -> str:
        """Generate .env.example content"""
        return """# Environment Variables Template
# Copy this file to .env and fill in your values

# Required: Anthropic API Key for Claude
ANTHROPIC_API_KEY=your_api_key_here

# Optional: Project-specific settings
PROJECT_NAME={project_name}
ENVIRONMENT=development
""".format(project_name=project.name.replace(" ", "_").upper())